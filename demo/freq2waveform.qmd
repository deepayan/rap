---
title: Converting frequencies to a waveform
format: html
execute:
  cache: true
---


Suppose we have a sequence of frequencies with durations, as in a
typical melody. Our goal is to convert this into a waveform. For now,
we consider pure frequencies with constant amplitude.

## Formulation and theoretical solution

Converting a frequency $\omega$ to a waveform $w_{\omega}$ is
trivial (but not unique):

$$
W_{\omega}(t) = \sin (2 \pi \omega t).
$$

The challenge is to make the waveform _continuous_ when the
frequencies change.

In music, frequencies are typically piecewise constant (especially for
keyboard-style instruments), but can also vary continuously with time,
especially for vocal music. We will assume that we are given a
function $\omega(t)$ which tells us the frequency at time $t$. We are
interested in evaluating a cooresponding _continuous_ waveform
$W_{\omega}(t)$ such that locally we can write

$$
W_{\omega}(t) = \sin (2 \pi \omega(t) t + c).
$$ {#eq-target}

where the "constant" $c$ is an adjustment to make the function
continuous, and depends on the history, changing whenever $\omega(t)$
changes. We will propose the following form, which we can easily show
will satisfy our requirements when $\omega(t)$ is locally constant:

$$
\widetilde{W}_{\omega}(t) = \sin (2 \pi s(t)), 
$$

where

$$
s(t) = \int\limits_{0}^{t} \omega(u) \text{d}u.
$$

$W_{\omega}(t)$ is continuous because $s(t)$ is continuous, and
behaves like (-@eq-target) when $\omega(t)$ is locally constant.

A more intuitive interpretation of this formulation is to think of
$s(t)$ as a "warping" of $t$ so that $\sin (2 \pi s)$ is a sine curve
with constant frequency 1.

## Implementation challenges

The values of $\omega(t)$ will be typically large, so there is a
chance that $s(t)$ will overflow. But as $\sin$ is periodic with a
period of 1, there is no difference between $s(t)$ and $s(t) \mod 1$.

So in principle, given $\omega(t), 0 < t < T$ we can do a discrete
approximation with sampling rate $R$ as follows:

```r
t <- seq(0, T, by = 1/R)
w <- omega(t)
s <- cumsum1(w / R)
W <- sin(2 * pi * s)
```

where `cumsum1(x)` takes cumulative sums of a vector modulo 1. The
only flaw in this approach (other than the numerical approximations
involved in approximating an integral by cumulative sums) is that this
is not vectorizable in the usual R sense. So we will use a compiled
implementation.

```{Rcpp}
#include <Rcpp.h>

// [[Rcpp::export]]
Rcpp::NumericVector cumsum1(Rcpp::NumericVector x) {
	int n = x.size();
	Rcpp::NumericVector y(n); y[0] = x[0];
    for (int i = 1; i < n; i++) y[i] = fmod(y[i-1] + x[i], 1.0);
	return y;
}
```

We will (eventually) implement `cumsum1` in C (using R's standard
foreign function interface, as it's too simple to warrant `Rcpp`).

```{r}
cumsum1(runif(100, max = 0.25)) |> plot(type = "o")
```


## Piecewise linear and constant $\omega(t)$

In practice, we will probably only deal with $\omega(t)$ that is
piecewise constant or linear. In such cases, the integrals canbe
computed more precisely ($s(t)$ is piecewise linear or
quadratic). However, we will leave this for later.


## Data

Should ideally come as a data frame with columns giving (a) transition
times starting from 0, (b) frequencies at the beginning of each
interval (last one is unused), (c) transition type
(discrete/continuous), and (d) whether new note or continuation of
previous note.

(d) will impact the amplitude profile (which we will think about
later).

Let's try a simple example.


```{r}
library(av)
library(rap)
```

Simulate some data:

```{r}
NOTES <- 440 * 2^(c(0, 2, 4, 5, 7, 9, 11, 12) / 12) # 440=A
BPS <- 4
n <- 20
music <- data.frame(time = seq(0, n/BPS, length.out = n),
                    freq = sample(NOTES, n, replace = TRUE),
                    transition = 0, # 0 = discrete, 1 = continuous
                    newnote = TRUE)
```


## Piecewise constant

Let's first define $\omega(t)$. For our first attempt, we will take
$\omega(t)$ to be piecewise constant, so we can simply use
`stepfun()`.

```{r}
omega <- with(music, stepfun(time, c(0, freq)))
plot(omega)
```

Next, let us generate the waveform using the algorithm above.

```{r}
R <- 44100
t <- seq(0, n/BPS, by = 1/R)
w <- omega(t)
s <- cumsum1(w / R)
W <- sin(2 * pi * s)
```

```{r}
outfile <- "random-music.mp3"
writeSignal(scaleSignal(W, qprob = 1), file = outfile, samp.rate = R)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```


## Piecewise linear

The more general form which should cover most use cases is a piecewise
linear $\omega(t)$. For this we will represent the function in terms
of contiguous intervals, with interval having a start and end time, as
well as a start and end frequency. This is sort of like the MIDI
model, except that we have no overlapping intervals and no silent
intervals.


Let's simulate music as before (but as a random walk), but this time
with each row giving an interval.

```{r}
NOTES <- 440 * 2^(c(0, 2, 4, 5, 7, 9, 11, 12) / 12) # 440=A
n <- 50
BPS <- 2
tt <- seq(0, n/BPS, length.out = n + 1)
note_seq <- sample(c(-1, 0, 1), n + 1, replace = TRUE) |> cumsum()
note_seq <- 1 + (note_seq %% 8)
note_seq[[1]] <- 1
music <- data.frame(tstart = head(tt, -1), tend = tail(tt, -1),
                    fstart = NOTES[head(note_seq, -1)],
                    fend = NOTES[tail(note_seq, -1)],
                    newnote = sample(c(TRUE, FALSE), n, replace = TRUE))
head(music)
```

Instead of writing a function (which we could if we really wanted),
let's just directly generate the pointwise evaluation.


```{r}
music2freq <- function(d, R = 44100) {
    n <- nrow(d)
    T <- d$tend[[n]] # end-time
    t <- seq(0, T, by = 1/R)
    ## find the starting index of each interval --- basically the
    ## first index which falls in that interval, but calculated
    ## efficiently.
    ##
    ## Start with something crude... FIXME improve
    kstart <- as.integer(length(t) * (d$tstart / T))
    kstart[[1]] <- 1
    kend <- c(kstart[-1], length(t))
    ans <- numeric(length(t))
    for (i in seq_len(n)) {
        ## print(i)
        L <- kend[i] - kstart[i] + 1
        ans[ kstart[i]:kend[i] ] <- d$fstart[i] +
            seq(0, 1, length.out = L) * (d$fstart[i] - d$fend[i])
    }
    ans
}
```



```{r}
R <- 44100
t <- seq(0, n/BPS, by = 1/R)
w <- music2freq(music, R) 
s <- cumsum1(w / R)
W <- sin(2 * pi * s)
```


```{r}
outfile <- "random-music-linear.mp3"
writeSignal(scaleSignal(W, qprob = 1), file = outfile, samp.rate = R)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```

So this seems to successfully demonstrate that we can vary frequency
continuously. What we still cannot handle is transitioning into
silence --- which is easy in principle; we just need to continue until
the waveform reaches zero before stopping. Or we can fake that using
volume (when we implement it eventually).

## Real music

For melodies (without any harmony) we should be able to proceed if
someone gives us a data frame in the format above. The most obvious
thing to try is Rabindrasangeet because the notation is [already
available](https://github.com/majantali/gitabitan). 

We could go via MIDI, but that is event-based (each note is a separate
event, not a continuation), so conceptually there is no guarantee that
there is exactly one frequency to play at every time point. So we will
instead try generating the data frame directly --- see
[here](https://github.com/majantali/gitabitan/blob/main/generate-freq-csv.R). The
following examples use output from this code.


```{r}
id <- "00032"
id = "01177"
id = "01071"
infile <- sprintf("~/git/github-majantali/gitabitan/frequency-duration/%s.csv", id)
freqs <- read.csv(infile)
## convert to frequency: Take A=57 as 440Hz
## convert time to seconds: Take duration=60 as L seconds
L <- 0.25
freqs <- within(freqs,
{
    tmin <- min(tstart)
    tstart <- L * (tstart - tmin) / 60
    tend <- L * (tend - tmin) / 60
    fstart <- 440 * 2^((kstart - 57) / 12)
    fend <- 440 * 2^((kend - 57) / 12)
})[c("tstart", "tend", "fstart", "fend", "newnote")]
head(freqs)

total.duration <- max(freqs$tend)
R <- 44100
t <- seq(0, total.duration, by = 1/R)
w <- music2freq(freqs, R)
s <- cumsum1(w / R)
W <- sin(2 * pi * s)
```

```{r}
outfile <- sprintf("./gitabitan/%s.mp3", id)
writeSignal(scaleSignal(W, qprob = 1), file = outfile, samp.rate = R)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```





