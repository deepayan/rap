---
title: AR modeling or Linear Predictive Coding
format: html
execute:
  cache: true
---


After many blind ends, things boil down to this:

- LPC or AR is a good generative model for speech:
  https://en.wikipedia.org/wiki/Linear_prediction

- We thus need to estimate the AR coefficients from an input signal

- The Durbin-Levinson algorithm does this from the ACF

- This is a Good Thing because the ACF looks like it might be amenable
  to modeling

- The drawback is causality --- not robust to small changes --- for
  which PACF might be better behaved if we can figure out how to use
  it.



```{r}
#| cache: false
library(av)
library(rap)
getACF <- function(x, ...)
{
    acf(x, ..., plot = FALSE, demean = FALSE)$acf[-1]
}
LAG_MAX <- 600
NOISE_SIGMA <- 0.0001
```


## Original audio

```{r}
## src <- "~/audio-samples/rabindranath-birpurush.mp3"
src <- ## "../samples/rabindranath-jhulan-1921.wav"
    "../samples/nayan_chhere_gele_chale.wav"
x <- read_audio_bin(src, channels = 1) |> scaleSignal()
(srate <- attr(x, "sample_rate"))
x <- head(x, srate * 120) |> tail(srate * 20) # 20 seconds
outfile <- "original-audio.mp3"
writeSignal(scaleSignal(x), file = outfile, samp.rate = srate)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```


## ACF

```{r}
m <- splitSignal(x, patch = 1024, overlap = 256 * 3) # 1024 # ~ 23 milliseconds
system.time(acf.coefmat <- apply(m, 2, getACF, lag.max = LAG_MAX, type = "correlation"))
system.time(pacf.coefmat <- apply(m, 2, getACF, lag.max = LAG_MAX, type = "partial"))
```




```{r}
matplot((acf.coefmat), type = "l", lty = 1, col = "#00000022")
lattice::levelplot(t(acf.coefmat[, ]), aspect = "fill", col.regions = hcl.colors) 

system.time(
    ar.coefmat <- apply(acf.coefmat, 2, acf2ar, lambda = 0.005)
)


```


```r
recons.ar <- generateAR(ar.coefmat, PATCHSIZE = 256,
                        innov.fun = rnorm, noise.sigma = NOISE_SIGMA)

outfile <- "generated-ar.coefmat.mp3"
writeSignal(scaleSignal(recons.ar, qprob = 0.75), file = outfile, samp.rate = srate)
```

```r
#| output: asis
writeAudioBlock(outfile)
```

Doesn't seem to do anything --- may need parameter tuning.


For comparison, direct estimation using `ar()` - in principle, can try
to reproduce this if it is actually based on ACF.



```{r}
#| label: get-ar-coefs
getARCoef <- function(x, ..., taper = TRUE)
{
    if (taper) x <- spec.taper(x, 0.5)
    ## ar(x, aic = FALSE, order.max = order, demean = FALSE, method = "burg")$ar
    ar(x, aic = FALSE, ..., demean = FALSE, method = "burg")$ar
}

system.time(
    ar.burgmat <- apply(m, 2, getARCoef, order.max = LAG_MAX)
)

recons.burg <- generateAR(ar.burgmat[,], PATCHSIZE = 256,
                          innov.fun = rnorm, noise.sigma = NOISE_SIGMA)

```

```{r}
#| cache: false
outfile <- "generated-ar.burgmat.mp3"
writeSignal(scaleSignal(recons.burg, qprob = 0.9), file = outfile, samp.rate = srate)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```

* * *

## AR from ACF using Levinson's algorithm 

Not stable, but may be worth pursuing as this seems standard.

```r
library(gsignal)
arcmat <- t(levinson(acf.coefmat, p = 400)$a)[-1, ]
recons.levinson.ar <-
    generateAR(arcmat[,], PATCHSIZE = 256,
               innov.fun = rnorm, noise.sigma = NOISE_SIGMA)
```


Not sure if this is correct. Maybe it's adapted from `signal::levinson`.

```{r}
system.time(
    macmat <- apply(acf.coefmat, 2, levinson.ma)
)
```

But reconstruction explodes.


```{r}
recons.levinson.ma <-
    generateAR(macmat[,], PATCHSIZE = 256,
               innov.fun = rnorm, noise.sigma = NOISE_SIGMA)

```

```{r}
#| cache: false
outfile <- "generated-ma.levinson.mp3"
writeSignal(scaleSignal(recons.levinson.ma, qprob = 0.9), file = outfile, samp.rate = srate)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```

* * *


## MA model --- use ACF as coefficients


```{r}
#| label: gen-ma
recons.ma <- generateMA(acf.coefmat, PATCHSIZE = 256,
                        innov.fun = rnorm, noise.sigma = NOISE_SIGMA)
```

not good, but retains essence + a lot of noise 

```{r}
#| cache: false
outfile <- "generated-ma.coefmat.mp3"
writeSignal(scaleSignal(recons.ma, qprob = 0.9), file = outfile, samp.rate = srate)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```

* * *


## Try denoising this by smoothing

```{r}
filterLP <- function(x, lambda = 20)
{
    ## Possible alternative transformations
    ## fftTrans <- transform.fft(delta = 4000, modulus.only = FALSE)
    ## ridgeTrans <- transform.ridge(filter = c(1, -2, 1), lambda = 500)
    ridgeTrans <- transform.ridge(filter = c(1, -1), lambda = 20)
    m <- splitSignal(x, 10 * 1024, 512)
    xx <- transformSignal(m, ridgeTrans, loop = FALSE) |> mergeSignal(overlap = 512)
    ## FIXME: some problem in calculation; xx longer
    L <- min(length(x), length(xx))
    x <- x[1:L]
    xx <- xx[1:L]
    xx
}
```

```{r}
#| label: low-pass-filter
x1 <- filterLP(recons.ma, lambda = 5)
```


```{r}
outfile <- "ma-smoothed.mp3"
writeSignal(scaleSignal(x1), file = outfile, samp.rate = srate)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```


## Try to make MA estimation better

Not simple, but let's try this silly algorithm:

* Start with auto-correlations $\hat\rho$

* Want to estimate MA coefficients $\theta$

* Initialize $\hat\theta = \hat\rho$ (with $\theta_0 = 1$)

* The defining relationship is

$$
\rho_k = \frac{ \theta_k + \theta_1 \theta_{1+k} + \dotsm + \theta_{q-k} \theta_q }{ 1 + \theta_1^2 + \dotsc + \theta_q^2 }
$$

* Using this, recursively define $C(\theta) = 1 + \theta_1^2 + \dotsc + \theta_q^2$ and update (for $k = 1, 2, \dotsc, q$)

$$
\theta_k = C(\theta) \hat\rho_k - (\theta_1 \theta_{1+k} + \dotsm + \theta_{q-k} \theta_q)
$$



```{r}
sillyMA <- function(rho, q = length(rho), niter = 10)
{
    rho <- head(rho, q)
    theta <- rho
    updateTheta <- function() {
        theta[] <- theta / max(abs(theta))
        C <- 1 + sum(theta^2)
        theta[] <<- C * rho - sapply(1:q, function(k) sum(head(theta, -k) * tail(theta, -k)))
    }
    replicate(niter, updateTheta())
    theta
}
```


```{r}
#| label: silly-ma
system.time(
    silly.macmat <- apply(acf.coefmat, 2, sillyMA, q = 500, niter = 2)
)
str(silly.macmat)
```



```{r}
#| label: gen-ma-2
#| cache: false
recons.sillyma <- generateMA(silly.macmat, PATCHSIZE = 256,  
                             innov.fun = rnorm, noise.sigma = NOISE_SIGMA * 10)
```



```{r}
#| cache: false
outfile <- "ma-silly.mp3"
writeSignal(scaleSignal(recons.sillyma), file = outfile,  samp.rate = srate)
```

```{r}
#| output: asis
writeAudioBlock(outfile)
```



```{r}
matplot((silly.macmat), type = "l", lty = 1, col = "#00000022")
```



```r

i <- sample(860, 1)
xyplot(ar.burgmat[, i] ~ ar.coefmat[, i],
       abline = c(0, 1), grid = TRUE, aspect = "iso",
       prepanel = function(x, y) {
           r <- quantile(c(x, y), c(0.01, 0.99))
           list(xlim = r, ylim = r)
       })

## very different!

levelplot(t(acf.coefmat[1:200, ]), aspect = "fill", col.regions = hcl.colors) 


levelplot(t(asinh(ar.coefmat)[1:200, ]), aspect = "fill", col.regions = hcl.colors) 

levelplot(t(asinh(ar.burgmat)[1:200, ]), aspect = "fill", col.regions = hcl.colors) 


## The sensitivity to AR coefficients is discouraging, but let's try
## at least a couple of things.

## 1. Estimate ACF a little differently: fixed number of lagged-products,

## 2. Replace ACFs by "smoothed" versions (maybe using splines)


matplot((acf.coefmat), type = "l", lty = 1, col = "#00000022")


library(splines)

smoothacf <- function(x)
{
    i <- seq_along(x)
    fm <- lm(x ~ bs(i, df = 30))
    fitted(fm)
}

I <- sample(ncol(acf.coefmat), 1)
plot(smoothacf(acf.coefmat[, I]), type = "l")
lines(seq_len(nrow(acf.coefmat)), acf.coefmat[, I], col = 3)

acf.smoothmat <- apply(acf.coefmat, 2, smoothacf)
matplot((acf.smoothmat), type = "l", lty = 1, col = "#00000022")

system.time(
    ar.coefmat <- apply(acf.smoothmat, 2, acf2ar, lambda = 0)
)


for (i in seq_len(ncol(ar.coefmat)))
{
    m <- max(abs(ar.coefmat[,i]))
    if (m > 2) ar.coefmat[-1,i] <- 0
}


matplot((ar.coefmat), type = "l", lty = 1, col = "#00000022")
abline(h = 0)

recons <- generateAR(ar.coefmat,
                     innov.fun = noise, kind = "white", noise.sigma = 0.1)
play(recons)

plot(recons)

## So this is a problem. Would it be enough to make sure that the
## input ACF is positive definite?


## Let's at least see if dimension reduction works in the sense that
## "close" in regression coefficients  means close in ACF


smoothCoef <- function(x)
{
    i <- seq_along(x)
    fm <- lm(x ~ bs(i, df = 30))
    ## coef(fm) / max(coef(fm))
    log(abs(coef(fm)[-1])) - log(abs(coef(fm)[1]))
}


I <- sample(ncol(acf.coefmat), 1)
smoothCoef(acf.coefmat[, I])

acf.smoothcoef <- apply(acf.coefmat, 2, smoothCoef)
matplot((acf.smoothcoef), type = "l", lty = 1, col = "#00000022")

matplot(t(acf.smoothcoef), type = "l", lty = 1, col = "#00000099")

str(acf.smoothcoef)

## Euclidian distance from previous point

d <- numeric(ncol(acf.smoothcoef))
d[1] <- Inf
for (i in 2:ncol(acf.smoothcoef))
{
    d[i] <- mean((acf.smoothcoef[, i] - acf.smoothcoef[, i-1])^2)
}

plot(d, type = "l")


if (FALSE)
{


    ## other more explicit distances
    ## m <- ar.coefmat
    m <- ar.burgmat
    d <- numeric(ncol(m))
    d[1] <- Inf
    for (i in 2:ncol(m))
    {
        d[i] <- mean((m[, i] - m[, i-1])^2)
    }
    plot(d, type = "l")

}


ar.simplemat <- ar.coefmat
for (i in seq_along(d))
{
    if (d[i] < 0.01)
    {
        cat(".")
        ar.simplemat[, i] <- ar.simplemat[, i-1]
    }
}



recons <- generateAR(ar.simplemat,
                     innov.fun = noise, kind = "white", noise.sigma = 0.1)
play(recons)



## What about eigenvalues of ACF matrix before and after
## approximating? This should show whether the function is p.d.


e1 <- apply(acf.coefmat, 2, smallestEigenvalue)

acf.smoothcoef <- apply(acf.coefmat, 2, smoothacf)

e2 <- apply(acf.smoothcoef, 2, smallestEigenvalue)


acf.smoothmat <-
    apply(acf.coefmat, 2,
          function(x) {
              s <- smoothacf(x)
              e <- smallestEigenvalue(s, lambda = 0)
              if (e < 0) s else x
          })


## does this at least lead to something reasonable?

system.time(
    ar.coefmat <- apply(acf.smoothmat, 2, acf2ar, lambda = 0)
)

recons <- generateAR(ar.coefmat,
                     innov.fun = noise, kind = "white", noise.sigma = 0.1)

plot(recons)
play(recons)


for (I in which(e2 > 0))
{
    plot(smoothacf(acf.coefmat[, I]), type = "l", main = e2[I])
    lines(seq_len(nrow(acf.coefmat)), acf.coefmat[, I], col = 3)
}

## try to approximate by PD

library(splines)

smoothacf <- function(x)
{
    i <- seq_along(x)
    fm <- lm(x ~ bs(i, df = 30))
    fitted(fm)
}


acf.smoothmat <- apply(acf.coefmat, 2, smoothacf)

acf.smoothpd <- apply(acf.smoothmat, 2, makePD)

system.time(
    ar.coefmat <- apply(acf.smoothpd, 2, acf2ar, lambda = 0)
)

recons <- generateAR(ar.coefmat,
                     innov.fun = noise, kind = "white", noise.sigma = 0.1)

plot(recons)
play(recons)


## Try solving as non-Toeplitz

system.time(
    ar.coefmat <- apply(acf.smoothmat, 2, acf2ar.pd, lambda = 0.01)
)

recons <- generateAR(ar.coefmat,
                     innov.fun = noise, kind = "white", noise.sigma = 0.1)

plot(recons)
play(recons)

```


